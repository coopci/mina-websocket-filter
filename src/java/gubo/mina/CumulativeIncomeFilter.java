package gubo.mina;

import java.util.Queue;

import org.apache.mina.core.buffer.IoBuffer;
import org.apache.mina.core.filterchain.IoFilterAdapter;
import org.apache.mina.core.filterchain.IoFilterChain;
import org.apache.mina.core.filterchain.IoFilter.NextFilter;
import org.apache.mina.core.session.AttributeKey;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.AbstractProtocolDecoderOutput;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;


abstract public class CumulativeIncomeFilter extends IoFilterAdapter {
	private final AttributeKey BUFFER = new AttributeKey(getClass(), "buffer");

	/**
	 * Creates a new instance.
	 */
	protected CumulativeIncomeFilter() {
		// Do nothing
	}

	@Override
	public void onPostRemove(IoFilterChain parent, String name,
			NextFilter nextFilter) throws Exception {
		this.dispose(parent.getSession());
	}

	@Override
	public void sessionClosed(NextFilter nextFilter, IoSession session)
			throws Exception {
		this.dispose(session);
	}

	public void dispose(IoSession session) {
		removeSessionBuffer(session);
	}

	private void storeRemainingInSession(IoBuffer buf, IoSession session) {
		final IoBuffer remainingBuf = IoBuffer.allocate(buf.capacity())
				.setAutoExpand(true);

		remainingBuf.order(buf.order());
		remainingBuf.put(buf);

		session.setAttribute(BUFFER, remainingBuf);
	}

	/**
	 * Implement this method to consume the specified cumulative buffer and
	 * decode its content into message(s).
	 * 
	 * @param in
	 *            the cumulative buffer
	 * @return <tt>non-null</tt> if and only if there's more to decode in the
	 *         buffer and you want to have <tt>doDecode</tt> method invoked
	 *         again. Return <tt>null</tt> if remaining data is not enough to
	 *         decode, then this method will be invoked again when more data is
	 *         cumulated.
	 * @throws Exception
	 *             if cannot decode <tt>in</tt>.
	 */
	protected abstract boolean doDecode(IoSession session, IoBuffer in, NextFilter nextFilter,
			ProtocolDecoderOutput out) throws Exception;

	public void messageReceived(NextFilter nextFilter, IoSession session,
			Object message) throws Exception {
		if (!(message instanceof IoBuffer)) {
			nextFilter.messageReceived(session, message);
			return;
		}
		ProtocolDecoderOutput decoderOut = getDecoderOut(session, nextFilter);
		synchronized (decoderOut) {
			IoBuffer in = (IoBuffer) message;
			// IoBuffer out = null;
			if (!session.getTransportMetadata().hasFragmentation()) {
				while (in.hasRemaining()) {
					if (doDecode(session, in, nextFilter, decoderOut)) {
						break;
					}
				}

				return;
			}

			boolean usingSessionBuffer = true;
			IoBuffer buf = (IoBuffer) session.getAttribute(BUFFER);

			if (buf != null) {
				boolean appended = false;
				// Make sure that the buffer is auto-expanded.
				if (buf.isAutoExpand()) {
					try {
						buf.put(in);
						appended = true;
					} catch (IllegalStateException e) {
						// A user called derivation method (e.g. slice()),
						// which disables auto-expansion of the parent buffer.
					} catch (IndexOutOfBoundsException e) {
						// A user disabled auto-expansion.
					}
				}

				if (appended) {
					buf.flip();
				} else {
					// Reallocate the buffer if append operation failed due to
					// derivation or disabled auto-expansion.
					buf.flip();
					IoBuffer newBuf = IoBuffer.allocate(
							buf.remaining() + in.remaining()).setAutoExpand(
							true);
					newBuf.order(buf.order());
					newBuf.put(buf);
					newBuf.put(in);
					newBuf.flip();
					buf = newBuf;

					// Update the session attribute.
					session.setAttribute(BUFFER, buf);
				}
			} else {
				buf = in;
				usingSessionBuffer = false;
			}

			for (;;) {
				int oldPos = buf.position();
				boolean decoded = doDecode(session, buf, nextFilter, decoderOut);
				if (decoded) {
					if (buf.position() == oldPos) {
						throw new IllegalStateException(
								"doDecode() can't return true when buffer is not consumed.");
					}

					if (!buf.hasRemaining()) {
						break;
					}
				} else {
					break;
				}
			}

			// if there is any data left that cannot be decoded, we store
			// it in a buffer in the session and next time this decoder is
			// invoked the session buffer gets appended to
			if (buf.hasRemaining()) {
				if (usingSessionBuffer && buf.isAutoExpand()) {
					buf.compact();
				} else {
					storeRemainingInSession(buf, session);
				}
			} else {
				if (usingSessionBuffer) {
					removeSessionBuffer(session);
				}
			}
		}

		decoderOut.flush(nextFilter, session);
		// nextFilter.messageReceived(session, message);
	}

	private void removeSessionBuffer(IoSession session) {
		session.removeAttribute(BUFFER);
	}

	private static class ProtocolDecoderOutputImpl extends
			AbstractProtocolDecoderOutput {
		public ProtocolDecoderOutputImpl() {
			// Do nothing
		}

		public void flush(NextFilter nextFilter, IoSession session) {
			Queue<Object> messageQueue = getMessageQueue();

			while (!messageQueue.isEmpty()) {
				nextFilter.messageReceived(session, messageQueue.poll());
			}
		}
	}

	/**
	 * Return a reference to the decoder callback. If it's not already created
	 * and stored into the session, we create a new instance.
	 */
	private ProtocolDecoderOutput getDecoderOut(IoSession session,
			NextFilter nextFilter) {
		ProtocolDecoderOutput out = (ProtocolDecoderOutput) session
				.getAttribute(DECODER_OUT);

		if (out == null) {
			// Create a new instance, and stores it into the session
			out = new ProtocolDecoderOutputImpl();
			session.setAttribute(DECODER_OUT, out);
		}

		return out;
	}

	private final AttributeKey DECODER_OUT = new AttributeKey(
			ProtocolCodecFilter.class, "decoderOut");
}
